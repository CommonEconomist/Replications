Z=(25*150)/(25+150)
x=150
for(i in 2:7){x[i]=x[i-1]-Z }
Z=(25*10)/(25+10)
A=25
X=150
Z=A*X/(A+X)
A=25
X=10
Z=A*X/(A+X)
Z/6
Z/7
(X-Z)/7
A=25
X=150
Z=A*X/(A+X)
Y=7
a<-150-Z/Y
a=150
for(i in 2:Y){a[i]=a[i-1]-Z/Y}
a
Z/Y
A=25
X=125
Z=A*X/(A+X)
(125-Z)/7
(125-Z)/6
swiss<-function(a,x){
z=a*x/(a+x)
}
swiss(25,150)
swiss<-function(a,x){
z=a*x/(a+x)
}
swiss(25,150)
swiss<-function(a,x){
z<-a*x/(a+x)
}
swiss(25,150)
swiss<-function(a,x){
z<-a*x/(a+x)
return(z)
}
swiss(25,150)
x=150
a=25
z=a*x\(a+x)
z=a*x/(a+x)
d=x
for(i in 2:6){d[i]=d[i-1]-(x-z)/6}
d
d=x
for(i in 2:7){d[i]=d[i-1]-(x-z)/6}
d
x=10
d2=x
for(i in 2:7){d2[i]=d2[i-1]-(x-z)/6}
d
x=10
z=a*x/(a+x)
d2=x
for(i in 2:7){d2[i]=d2[i-1]-(x-z)/6}
2
d2
x=100
a=25
z=a*x/(a+x)
d=x
for(i in 2:7){d[i]=d[i-1]-(x-z)/6}
x=50
z=a*x/(a+x)
d2=x
for(i in 2:7){d2[i]=d2[i-1]-(x-z)/6}
x=10
z=a*x/(a+x)
x=10
z=a*x/(a+x)
d3=x
for(i in 2:7){d3[i]=d3[i-1]-(x-z)/6}
par(mar=c(4,4,2,2),las=1,bty="n",cex.lab=2,cex.axis=2)
plot(d,type="l",lwd=2,xlab="",ylab="Tariff rate",axes=FALSE,ylim=c(0,100))
par(mar=c(4,5,2,2),las=1,bty="n",cex.lab=2,cex.axis=2)
plot(d,type="l",lwd=2,xlab="",ylab="Tariff rate",axes=FALSE,ylim=c(0,100))
lines(d2,lty=2,lwd=2,col="steelblue4")
lines(d2,lty=3,lwd=2,col="firebrick3")
par(mar=c(4,5,2,2),las=1,bty="n",cex.lab=2,cex.axis=2)
plot(d,type="l",lwd=2,xlab="",ylab="Tariff rate",axes=FALSE,ylim=c(0,100))
lines(d2,lty=2,lwd=2,col="steelblue4")
lines(d3,lty=3,lwd=2,col="firebrick3")
axis(1,tick=FALSE)
axis(2,tick=FALSE)
x=50
a=25
z=a*x/(a+x)
d=x
for(i in 2:7){d[i]=d[i-1]-(x-z)/6}
x=25
z=a*x/(a+x)
d2=x
for(i in 2:7){d2[i]=d2[i-1]-(x-z)/6}
x=10
z=a*x/(a+x)
d3=x
for(i in 2:7){d3[i]=d3[i-1]-(x-z)/6}
par(mar=c(4,5,2,2),las=1,bty="n",cex.lab=2,cex.axis=2)
plot(d,type="l",lwd=2,xlab="",ylab="Tariff rate",axes=FALSE,ylim=c(0,50))
lines(d2,lty=2,lwd=2,col="steelblue4")
lines(d3,lty=3,lwd=2,col="firebrick3")
axis(1,tick=FALSE)
axis(2,tick=FALSE)
par(mar=c(4,5,2,2),las=1,bty="n",cex.lab=2,cex.axis=2)
plot(d,type="l",lwd=2,xlab="",ylab="",axes=FALSE,ylim=c(0,50))
lines(d2,lty=2,lwd=2,col="steelblue4")
lines(d3,lty=3,lwd=2,col="firebrick3")
axis(1,tick=FALSE)
axis(2,tick=FALSE)
par(mar=c(4,5,2,2),las=1,bty="n",cex.lab=2,cex.axis=2)
plot(d,type="l",lwd=2,xlab="",ylab="",axes=FALSE,ylim=c(0,50))
lines(d2,lty=2,lwd=2,col="steelblue4")
lines(d3,lty=3,lwd=2,col="firebrick3")
axis(1,tick=FALSE,at=1:7,label=0:6)
axis(2,tick=FALSE)
exp(0.31)
exp(0.12)
require(wdi)
#### GDP per capita ####
require(WDI)
#### Openness of trade ####
gdp_m<-WDIsearch("growth",field="name",short=FALSE) # 27
trade_m<-WDIsearch("trade",field="name",short=FALSE) # 108
wdi<-WDI(iso2c,c(gdp_m[27,1],trade_m[108,1]),start=2000,end=2015)
# ISO2C
require(countrycode)
data(countrycode_data)
cc<-countrycode_data
iso2c<-cc$iso2c
#### Openness of trade ####
gdp_m<-WDIsearch("growth",field="name",short=FALSE) # 27
trade_m<-WDIsearch("trade",field="name",short=FALSE) # 108
wdi<-WDI(iso2c,c(gdp_m[27,1],trade_m[108,1]),start=2000,end=2015)
# Aggregate data
d<-ddply(wdi,.(iso2c),summarise,
gdp_g=mean(NY.GDP.MKTP.KD.ZG,na.rm=TRUE),
trade=mean(NE.TRD.GNFS.ZS,na.rm=TRUE))
# Plot data
par(mfrow=c(1,1))
plot(d$gdp_g,d$trade,xlim=c(-5,15),ylim=c(5,420),axes=FALSE,
xlab="GDP growth",ylab="Trade relative to GDP",log="y")
# Aggregate data
d<-ddply(wdi,.(iso2c),summarise,
gdp_g=mean(NY.GDP.MKTP.KD.ZG,na.rm=TRUE),
trade=mean(NE.TRD.GNFS.ZS,na.rm=TRUE))
require(plyr)
# Aggregate data
d<-ddply(wdi,.(iso2c),summarise,
gdp_g=mean(NY.GDP.MKTP.KD.ZG,na.rm=TRUE),
trade=mean(NE.TRD.GNFS.ZS,na.rm=TRUE))
# Plot data
par(mfrow=c(1,1))
plot(d$gdp_g,d$trade,xlim=c(-5,15),ylim=c(5,420),axes=FALSE,
xlab="GDP growth",ylab="Trade relative to GDP",log="y")
axis(1,tick=FALSE);axis(2,tick=FALSE,line=-1)
mean(d$trade)
mean(d$trade,na.rm=TRUE)
?ttest
?t.test
z.test<-function(b1,b2,se1,se2){
zeta=(b1-b2)/(sqrt(se1^2+se2^2))
return(zeta)
}
z.test(5,3,1,1.5)
pnorm( -14.11765)
pnorm(-14.11765)
#### Simulate data ####
# Start with generating normal mortality rates, pre- and during-war period.
# Mortality rates are independent of each other.
# Use zero-inflated Poisson distribution
library(VGAM)
set.seed(42);mort.pre=rzipois(2000,lambda=1, pstr0=.95);table(mort.pre)
set.seed(43);mort.post=rzipois(2000,lambda=1, pstr0=.95);table(mort.post)
# Combine data in data frame
df<-data.frame(hh=1:2000,cluster=rep(1:100,each=20),
mort.pre=mort.pre,mort.post=mort.post)
names(df)
sum(df$mort.pre)
96/10000
96/10
sum(df$mort.post)
install.packages(c("hms", "Rcpp", "RcppEigen", "rgdal", "spatstat", "spatstat.data", "spatstat.utils", "spdep", "stringi"))
d<-read.csv('/home/swl/Dropbox/Sandbox/new_data/WFPVAM_FoodPrices_24-7-2017.csv',
stringsAsFactors=FALSE)
names(d)
bf<-d[d$adm0_name=='Burkina Faso']
bf<-d[d$adm0_name=='Burkina Faso',]
names(bf)
table(bf$cm_name)
cm<-c('Millet','Maize','Sorghum')
bf<-d[d$adm0_name=='Burkina Faso' &
d$cm_name %in% c('Millet','Maize','Sorghum') ,]
table(bf$cm_name)
length(unique(bf$mkt_name))
names(bf)
summary(bf$mp_year)
table(bf$mp_year)
table(bf$mkt_name)
x<-bf[bf$mkt_name=='Ouagadougo (Sankaryare)' &
bf$cm_name=='Millet',]
View(x)
names(x)
p<-ts(x$mp_price,start=c(1992,1),frequency=12)
plot(p)
names(d)
table(d$cm_name)
a<-bf<-d[d$adm0_name=='Burkina Faso',]
table(a$cm_name)
x<-bf[bf$mkt_name=='Dori' &
bf$cm_name=='Millet',]
p<-ts(x$mp_price,start=c(1992,1),frequency=12)
plot(p)
plot(log(p))
plot(diff(log(p)))
N=1000
?rnorm
pre<-rnorm(N,5,1)
during<-rnorm(N,5,1)
cdr<-rnorm(N,5,1)
cdr2<-cdr+rnorm(1000,0,1)
summary(cdr)
summary(cdr2)
v<-rnorm(N,1,.1)
summary(v)
P=20000000
P=25000000
edr<-(cdr2+v)-cdr
boxplot(edr)
table(edr>0)
edr2<-cdr2-cdr
table(edr2>0)
hist(edr)
hist(edr2)
X<-cbind(1,6.9,0.36,1.97,0,0,0,0.55,0.07,3.22,3.10,20.97,timeseq,timeseq^2,timeseq^3)
timeseq=0:180
X<-cbind(1,6.9,0.36,1.97,0,0,0,0.55,0.07,3.22,3.10,20.97,timeseq,timeseq^2,timeseq^3)
load("~/Dropbox/Sandbox/bellum/output/power_law_ksg.RData")
post.pl
1000^-1.5
10000^-1.5
100000^-1.5
10000^-1.5
10000^-2
10000^-1
(10000/1000)^(1-1.5)
(6/1)^(-1.5)
6^-2.5
(1.5/.5)
(100000/1000)^(1-1.5)
load("~/Dropbox/Sandbox/bellum/output/ratio_wars.RData")
(2003-1946)/nrow(d.post)
(1945-1816)/nrow(d.pre)
2003+45
par(mar=c(5,5,2,2),mfrow=c(1,3),bty='n',pty='s',las=1,cex.lab=2,cex.axis=2)
hist(r3,breaks=50,axes=FALSE,xlab='',ylab='')
abline(v=or3,lwd=2)
hist(r3,breaks=30,axes=FALSE,xlab='',ylab='')
par(mar=c(5,5,2,2),mfrow=c(1,3),bty='n',pty='s',las=1,cex.lab=2,cex.axis=2)
hist(r3,breaks=30,axes=FALSE,xlab='',ylab='')
abline(v=or3,lwd=2)
axis(1,tick=FALSE);axis(2,tick=FALSE)
hist(r4,breaks=30,axes=FALSE,xlab='',ylab='')
abline(v=or4,lwd=2)
axis(1,tick=FALSE);axis(2,tick=FALSE)
hist(r5,breaks=30,axes=FALSE,xlab='',ylab='')
abline(v=or5,lwd=2)
axis(1,tick=FALSE);axis(2,tick=FALSE)
par(mar=c(5,5,2,2),mfrow=c(1,3),bty='n',pty='s',las=1,
cex.lab=2,cex.axis=2,cex.main=2)
hist(r3,breaks=30,axes=FALSE,xlab='',ylab='',main='10^3/10^4')
abline(v=or3,lwd=2)
axis(1,tick=FALSE);axis(2,tick=FALSE)
hist(r4,breaks=30,axes=FALSE,xlab='',ylab='',main='10^4/10^5')
abline(v=or4,lwd=2)
axis(1,tick=FALSE);axis(2,tick=FALSE)
hist(r5,breaks=30,axes=FALSE,xlab='',ylab='',main='10^5/10^6')
abline(v=or5,lwd=2)
axis(1,tick=FALSE);axis(2,tick=FALSE)
sum(r3<or3,na.rm=TRUE)/length(r3)
sum(r4<or4,na.rm=TRUE)/length(r4)
sum(r5<or5,na.rm=TRUE)/length(r5)
load("~/Dropbox/Sandbox/mortality/output/no_change.RData")
.45*.6
a<-read.csv('~/Downloads/temp.csv', stringsAsFactors=FALSE)
table(a[,1])
a<-read.csv('~/Downloads/201700Crn39502Grades.csv',stringsAsFactors=FALSE)
names(a)
table(a$Final.Grade)
a<-read.csv('~/Downloads/201700Crn39502Grades (1).csv',stringsAsFactors=FALSE)
table(a$Final.Grade)
View(a)
27/191
23/168
install.packages(c("backports", "curl", "dfoptim", "digest", "foreach", "git2r", "iterators", "MCMCpack", "plotrix", "RcppArmadillo", "reshape2", "Rttf2pt1", "spData", "splines2", "withr", "xts"))
d<-read.csv("temp.csv",header=FALSE)
x<-d[,1]
median(x)
## Test effect decay parameter on strength instrument
setwd("~/Dropbox/Refugee_environment/Data/R")
library(AER)
library(plyr)
#### Prepare data ####
load('data/input.RData')
load("data/proxy_test.RData")
x<-X[,c('id','pcode','year','iso','ref_pc','iso_recipient')]
test<-test[,c('province','iso','year','k','refugees','pop.Os')]
test$id<-as.character(test$province)
# Vectors
alpha=seq(.5,5,.1);N=length(alpha)
aic<-c();beta<-c();t<-c();R<-c();S<-c()
?ivreg
names(d)
names(x)
#### Prepare data ####
load('data/input.RData')
load("data/proxy_test.RData")
names(x)
names(X)
x<-X[,c('id','pcode','year','iso','ref_pc','iso_recipient','evi')]
test<-test[,c('province','iso','year','k','refugees','pop.Os')]
test$id<-as.character(test$province)
# Vectors
alpha=seq(.5,5,.1);N=length(alpha)
aic<-c();beta<-c();t<-c();R<-c();S<-c()
test$prox=1/test$k^alpha[1]
test$iv<-test$prox*test$refugees*test$pop.Os
# Aggregate data
iv<-ddply(test,.(iso,id,year),summarise,test=sum(iv,na.rm=TRUE))
# Merge data
d<-merge(x,iv,all.x=TRUE)
# Subset data
d<-na.omit(d[d$iso_recipient==1,])
# Fit model, with country and year fixed effects
m<-ivreg(ref_pc~evi +factor(year) +factor(pcode) |
test + factor(year) + factor(pcode),d)
names(d)
# Fit model, with country and year fixed effects
m<-ivreg(ref_pc~ evi + factor(year) +factor(pcode) | test + factor(year) + factor(pcode),d)
summary(d)
d2<-na.omit(d)
# Fit model, with country and year fixed effects
m<-ivreg(ref_pc ~ evi + factor(year) +factor(pcode) | test + factor(year) + factor(pcode),data=d)
summary(m)
setwd('~/Dropbox/github/replications/2014_Friedman')
#### 1) Prepare UCDP-GED data ####
load("data_raw/ged171.Rdata")
library(poweRlaw)
#source("code/clean_data.R") # Run twice because of error, takes some seconds
load("data/input.RData")
source("code/functions.R")
#InterPL(ged1) # Period Hagopian et al.
InterPL(ged2) # Period Wikileaks
InterPL(wikileaks)
## Replication "Using Power Laws to Estimate Conflict Size"
# http://jcr.sagepub.com/content/59/7/1216
library(haven)
dat<-read_dta("American Indian Wars event data.dta")
dat<-read_dta("data/American Indian Wars event data.dta")
x<-dat$recordeduscasualties # Change data according to taste
#### Fit power law to data ####
pl=displ$new(na.omit(x))
est=estimate_xmin(pl)
pl$setXmin(est)
plot(pl);lines(pl,col="red") # Visual inspection
Xmin<-pl$xmin
alpha<-pl$pars
## Indices
a=1:max(x,na.rm=TRUE)
n=1:max(x,na.rm=TRUE)
## Calculate frequency per event size
for(i in 1:length(n)){
n[i]=sum(x==i,na.rm=TRUE)
}
## Set parameters
if (Xmin>1){
S=cumsum(n)
lambda=S[length(S)]-S[Xmin-1] # Need to find out what lambda actually is
K<-99999999
Z<-sum(1/(0:K+Xmin)^alpha) # Hurwitz zeta normalisation constant
}
## Estimate number of incidents and fatalities
# Slight differences can occur.
Proj<-c()
for (j in 1:Xmin-1){
Proj[j]=lambda*a[j]^((-1)*alpha)*1/Z
}
R<-a[1:length(Proj)]*Proj # Number of fatalities
## Test fatality interpolation for Iraq
# Using method from Friedman (2014)
# http://jcr.sagepub.com/content/59/7/1216
options(scipen=4)
library(poweRlaw)
## Test fatality interpolation for Iraq
# Using method from Friedman (2014)
# http://jcr.sagepub.com/content/59/7/1216
options(scipen=4)
library(poweRlaw)
#source("code/clean_data.R") # Run twice because of error, takes some seconds
load("data/input.RData")
# Fit power law
x<-ged2
pl=displ$new(x)
est=estimate_xmin(pl)
pl$setXmin(est)
Xmin<-pl$xmin
alpha<-pl$pars
# Give summary
print(paste("alpha=",round(alpha,digits=2)))
print(paste("Xmin=",Xmin))
# Fit power law
x<-ged2
pl=displ$new(x)
est=estimate_xmin(pl)
pl$setXmin(est)
pl$setXmin(est);pl
bts<-bootstrap(pl,no_of_sims=2000,threads=3)
alpha<-bts$bootstraps$pars
xmin<-bts$bootstraps$xmin
summary(xmin)
summary(alpha)
a=1:max(x)
n=1:max(x)
####
N<-length(alpha)
mort<-c()
a=1:max(x)
n=1:max(x)
for(y in 1:N){
print(y)
Xmin=xmin[y]
Alpha=alpha[y]
for(i in 1:length(n)){
n[i]=sum(x==i,na.rm=TRUE)
}
# Set parameters (can take a few moments)
if (Xmin>1){
S=cumsum(n)
lambda=S[length(S)]-S[Xmin-1]
K<-99999999
Z<-sum(1/(0:K+Xmin)^Alpha) # Hurwitz zeta normalisation constant
}
# Estimate number of incidents and fatalities
Proj<-c()
for (j in 1:Xmin-1){
Proj[j]=lambda*a[j]^((-1)*Alpha)*1/Z
}
R<-a[1:length(Proj)]*Proj # Number of fatalities
mort[y]=round(sum(x[x>=Xmin])+sum(R),digits=2))
}
for(y in 1:N){
print(y)
Xmin=xmin[y]
Alpha=alpha[y]
for(i in 1:length(n)){
n[i]=sum(x==i,na.rm=TRUE)
}
# Set parameters (can take a few moments)
if (Xmin>1){
S=cumsum(n)
lambda=S[length(S)]-S[Xmin-1]
K<-99999999
Z<-sum(1/(0:K+Xmin)^Alpha) # Hurwitz zeta normalisation constant
}
# Estimate number of incidents and fatalities
Proj<-c()
for (j in 1:Xmin-1){
Proj[j]=lambda*a[j]^((-1)*Alpha)*1/Z
}
R<-a[1:length(Proj)]*Proj # Number of fatalities
mort[y]=round(sum(x[x>=Xmin])+sum(R),digits=2)
}
summary(mort)
for(y in 50:N){
print(y)
Xmin=xmin[y]
Alpha=alpha[y]
for(i in 1:length(n)){
n[i]=sum(x==i,na.rm=TRUE)
}
# Set parameters (can take a few moments)
if (Xmin>1){
S=cumsum(n)
lambda=S[length(S)]-S[Xmin-1]
K<-99999999
Z<-sum(1/(0:K+Xmin)^Alpha) # Hurwitz zeta normalisation constant
}
# Estimate number of incidents and fatalities
Proj<-c()
for (j in 1:Xmin-1){
Proj[j]=lambda*a[j]^((-1)*Alpha)*1/Z
}
R<-a[1:length(Proj)]*Proj # Number of fatalities
mort[y]=round(sum(x[x>=Xmin])+sum(R),digits=2)
}
summary(mort)
plot(hist(mort))
plot(hist(mort),breaks=100)
dev.off()
plot(hist(mort,breaks=100))
mean(mort)
sd(mort)
plot(density(mort))
plot(density(mort),log='x')
abline(v=mean(mort))
median(mort)
